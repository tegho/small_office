TOC:
<!-- TOC -->

- [Описание пакетов](#%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%BE%D0%B2)
    - [my-repo](#my-repo)
    - [docker-repo](#docker-repo)
    - [certbot-snap-assist](#certbot-snap-assist)
    - [ddns-afraid-org](#ddns-afraid-org)
    - [backup-to-ssh](#backup-to-ssh)
    - [crypt-pki](#crypt-pki)
        - [Создание контейнера](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0)
        - [Открытие контейнера debug](#%D0%BE%D1%82%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0-debug)
        - [Закрытие контейнера debug](#%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%B9%D0%BD%D0%B5%D1%80%D0%B0-debug)
        - [Произвольная команда debug](#%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0-debug)
        - [Создать запрос на сертификат](#%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D1%82%D1%8C-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82)
        - [Загрузить запрос на сертификат](#%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%B8%D1%82%D1%8C-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D0%BD%D0%B0-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82)
        - [Подписание запроса сервер](#%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0-%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80)
        - [Подписание запроса клиент](#%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0-%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82)
        - [Информация о сертификате](#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F-%D0%BE-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%B5)
        - [Отзыв сертификата](#%D0%BE%D1%82%D0%B7%D1%8B%D0%B2-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%B0)
        - [Новый CRL](#%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9-crl)
        - [Шаблоны конфигурации OpenVpn](#%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D1%8B-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D0%B8-openvpn)
        - [Клиентский конфиг OpenVpn из шаблона](#%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D1%81%D0%BA%D0%B8%D0%B9-%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3-openvpn-%D0%B8%D0%B7-%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD%D0%B0)
        - [Экспорт цепочки сертификатов PKCS #12](#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B8-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D0%B2-pkcs-12)
        - [Экспорт ответа на запрос сертификата PKCS #7](#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D0%B0-%D0%BD%D0%B0-%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%B0-pkcs-7)
        - [Экспорт цепочки сертификатов ZIP](#%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D1%86%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B8-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D0%B2-zip)
        - [Переменные окружения](#%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BE%D0%BA%D1%80%D1%83%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
        - [Примеры](#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B)
    - [setup-montana](#setup-montana)
    - [setup-nevada](#setup-nevada)
    - [setup-ohio](#setup-ohio)

<!-- /TOC -->


# Описание пакетов

## my-repo

    Пакет устанавливает deb репозиторий. Открытый ключ репозитория копируется в `/etc/apt/keyrings` и ссылка на репозиторий в `/etc/apt/sources.list.d`.

    Важно поддерживать актуальным открытый ключ, поэтому при компиляции пакета скрипт `2.change-files.sh` принимает аргументом командной строки путь к файлу открытого ключа. Если аргумент не указан, то ключ берется из каталога с ключами, на который указывает переменная `secret_dir` в файле `/vars` в корне git репозитория. По умолчанию открытый ключ находится в файле `/keys/apt-repo/apt-repo.public`.

    Также следует учитывать номер версии в имени файла пакета при публикации ссылки на него и составлении инструкции для установки.

  

## docker-repo

    Пакет устанавливает deb репозиторий docker-engine. При установке автомитически выполняются шаги, описанные в инструкции `https://docs.docker.com/engine/install/debian/#install-using-the-repository`

Назначение пакета - автоматизировать добавление deb репозитория docker.

    При установке пакета не выполняется установка каких-либо пакетов docker, только сам репозиторий.

## certbot-snap-assist

    Пакет устанавливает актуальную версию certbot из snap. При установке автоматически выполняются шаги, описанные в инструкции `https://certbot.eff.org/instructions?ws=other&os=snap`

## ddns-afraid-org

    Пакет устанавливает инструменты для автоматического обновления DNS записей на afraid.org. Текущая версия использует средства systemd и не поддерживает другие варианты.

    После установки и далее каждые 20 минут выполняется сервис `ddns-afraid-org.service`. Сервис запускает `/usr/libexec/ddns-afraid-org/update-ddns.sh`.

    При каждом запуске сервиса проверяется каталог `/etc/ddns-afraid-org.d` в поиске файлов конфигурации с расширением `.conf`. Пример такой конфигурации содержится в файле `/etc/ddns-afraid-org.d/example.conf`.

    Файл конфигурации может содержать строки комментариев, начинающихся с `#`, а также строки формата переменная=значение. В текущей версии поддерживается только переменная DDNS_URL, которая содержит строковое значение ссылки URL для обновления DNS. Если DDNS_URL обнаружен то указанный URL открывается curl или wget, в противном случае файл конфигурации игнорируется. Результат обработки каждого файла конфигурации записывается в syslog. Файл конфигурации с именем `example.conf` никогда не обрабатывается.

    Важно следить, чтобы файлы конфигурации в `/etc/ddns-afraid-org.d` были недоступны для посторонних, поскольку открытие ссылок с другого ip адреса приведет к нежелательной смене адреса, на который указывает DNS запись.

## backup-to-ssh

        Пакет устанавливает инструменты для автоматического резервного копирования данных на сторонний сервер по SSH. Текущая версия использует средства systemd и не поддерживает другие варианты.

    После установки и далее каждые сутки в 00:11:00 выполняется сервис `backup-to-ssh.service`. Сервис запускает `/usr/libexec/backup-to-ssh/backup-to-ssh.sh`

    При каждом запуске сервиса проверяется каталог `/etc/backup-to-ssh.d` в поиске файлов конфигурации с расширением `.conf`. Пример такой конфигурации содержится в файле `/etc/backup-to-ssh.d/example.conf`.

    Файл конфигурации может содержать строки комментариев, начинающихся с `#`, а также строки формата переменная=значение. Поддерживаемые переменные:

**`label`** - используется для идентификации в пути назначения на сервере SSH.

**`ssh_userhost`** - строковое значение в формате `user@host` для подключения по SSH.

**`private_key`** - полный путь к файлу закрытого ключа для подключения к серверу SSH. При установке пакета автоматически создается каталог `/etc/backup-to-ssh.keys` для хранения ключей.

**`object_to_backup`** - полный путь к каталогу или файлу, подлежащего резервному копированию. Для резервного копирования нескольких объектов для каждого следует создать отдетьный файл конфигурации.

**`keep_recent`** - количество последних успешных резервных копий, которые будут храниться на сервере SSH.

    Результат обработки каждого файла конфигурации записывается в syslog. Файл конфигурации с именем `example.conf` никогда не обрабатывается.

    Каждая резервная копия сначала создается локально путем архивации указанного объекта, затем вычисляется hash сумма архива. Полученный архив копируется на сервер SSH в `$HOME/backups/$label/${label}_$timestamp.tgz` где снова вычисляется hash сумма. Если на любом из этапов произошла ошибка, резервное копирование считается неудачным, скопированный файл удаляется. Если в целевой папке скопилось более чем **`keep_recent`** архивов, самые старые удаляются.

    Для мониторинга резервного копирования в случае успеха создается файл `/var/lib/prometheus/node-exporter/backup-to-ssh-$label.prom`, в который записывается текущее время на момент завершения всех проверок. Таким образом результат можно видеть в выводе prometheus node-exporter, если он установлен.

## crypt-pki

    Пакет устанавливает средства для создания и работы с шифрованным контейнером PKI.

    Шифрованный контейнер представляет из себя файл, зашифрованный LUKS контейнер, который содержит в себе файлы PKI. Конетйнер создается силами утилиты `cryptsetup`, а структура PKI создается и обслуживается `easy-rsa`.  Для работы с PKI и контейнером устанавливается утилита `/usr/bin/crypt-pki`. Такой способ работы делает относительно безопасным храниние, обработку и резервное копирование PKI, в том числе создание снапшотов диска, поскольку утилита `crypt-pki` не выносит критически важные данне за пределы контейнера.

    Кроме того поддерживается хранение в контейнере шаблонов конфигурационных файлов для клиентов OpenVpn. Таким образом, администратору удобно выпускать сертификаты клиентов и создавать файлы конфигурации с одного рабочего места.

    Поскольку утилита `crypt-pki` является оберткой над `easy-rsa`, допускается использовать переменные окружения `easy-rsa`, применимые в контексте выполняемой операции. Чаще всего переменные окружения используются для указания паролей к закрытым ключам или экспортируемым сертификатам. Если логика работы `easy-rsa` подразумевает указания пароля и он не задан переменными окружения, то он будет запрошен интерактивно. Тот же принцип применим для работы с LUKS контейнером.

    Логика работы `easy-rsa` предполагает обращение к сертификатам по имени файла без указания расширения. В описании уилиты `crypt-pki` для указания этого имени файла используется параметр `internalname`, там где это применимо.

    Первым параметром `crypt-pki` всегда указывается файл LUKS контейнера `cryptfile`.

    При запуске без параметров `crypt-pki` выводит справку.

    При успешном выполнении `crypt-pki` возвращает 0.

### Создание контейнера

    `crypt-pki cryptfile --init [--size size] [--url "http://example.com/crl"]`

    Команда `--init` создает LUKS контейнер и выполняет  инициализацию структуры PKI. Контейнер не должен существовать.

    При создании контейнера файлы утилиты `easy-rsa` копируются из каталога `/usr/share/easy-rsa` внутрь контейнера. Таким образом снижается риск повреждения PKI при обновлении `easy-rsa` и изменении логики работы. Обновление версии `easy-rsa` внутри контейнера следует проводить вручную.

    `--size` означает размер в мегабайтах (MiB) файловой системы ext4 внутри контейнера. Минимальный размер 8 MiB (3.5 MiB данные +журнал). По умолчанию размер равен 12 MiB (7.3 MiB данные +журнал). Размер контейнера всегда  будет больше значения `--size` на 16 MiB из-за LUKS заголовков.

    `--url` содержит URL, которая указывает на CRL для этого PKI. Адрес CRL будет записываться в CA и другие генерируемые сертификаты. URL должен указывать на http ресурс. Использование https или других протоколов не предусмотрено стандартом, хотя и поддерживается некоторыми клиентами. Файл CRL должен отдаваться веб сервером с MIME application/pkix-crl.

>     Если `--url` указан, то файл CRL необходимо перегенерировать каждые 180 дней или менее, иначе устаревший CRL отклоняется сервером и клиентский сертификат не может пройти проверку.

    Если контейнер успешно создан и инициализирован, команда завершится с кодом 0 и в stdout будет выведен ключ для доступа к новому контейнеру. Ключ генерируется автоматически и не может быть задан пользователем.

### Открытие контейнера (debug)

    `crypt-pki cryptfile --open`

    Команда расшифровывает и монтирует контейнер. Используется только для отладки или кастомных операций с PKI. Другие команды выполняют эту операцию автоматически. На каталог монтирования устанавливаются режим доступа 700.

    Важно не забывать закрывать и отмонтировать контейнер командой `--close` после завершения работы с ним.

    В случае успеха завершается с кодом 0 и в stdout выводится путь монтирования.

### Закрытие контейнера (debug)

    `crypt-pki cryptfile --close`

    Команда отмонтирует контейнер. Используется только для отладки или кастомных операций с PKI. Другие команды выполняют эту операцию автоматически.

    Важно закрыть все файловые дескрипторы внутри контейнера перед выполнением команды.

    В случае успеха завершается с кодом 0.

### Произвольная команда (debug)

    `crypt-pki cryptfile --exec --cmd "cmdline"`

    Команда выполняет произвольную инструкцию внутри контейнера. Используется для прямых вызовов `easy-rsa`, операций с файлами PKI.

    При вызове сначала контейнер расшифровывается и монтируется. Устанавливается переменная окружения `SECD`, которая содержит каталог монтирования, текущий каталог меняется на каталог монтирования. Выполняется инструкция `--cmd` через вызов `eval`.  Важно отметить, что инструкция может выполнять работу с любыми файлами доступными действующему пользователю, в том числе и выше точки монтирования. После выполнения инструкции текущий каталог возвращается и контейнер закрывается.

    В случае успеха всех шагов и возврата инструкции с 0 кодом, завершается с кодом 0.

### Создать запрос на сертификат

    `crypt-pki cryptfile --newreq [--cn CN] --internalname internalname [--nopass]`

    Генерирует закрытый ключ и новый запрос на сертификат. Пароль для закрытого ключа задается переменной окружения `EASYRSA_PASSOUT` или запрашивается интерактивно.

    `--cn` строковое значение CN RDN в создаваемом запросе. Если CN не указан, то он устанавливается равным значению `--internalname`.

    `--internalname` имя файла ключа и запроса для easy-rsa. Если закрый ключ с таким именем уже существует, возвращается ошибка. Если закрытый ключ отсутствует, но запрос с таким именем существует, то такой запрос будет перезаписан.

    `--nopass` не шифровать закрытый ключ паролем.

В случае успеха завершается с кодом 0.

### Загрузить запрос на сертификат

    `crypt-pki cryptfile --loadreq --file filename [--internalname internalname]`

    Загружает запрос на сертификат из внешнего файла в структуру PKI внутри контейнера.

    `--file` путь к файлу запроса.

    `--internalname` имя файла ключа и запроса для easy-rsa. Если не задан, то берется из `--file` без учета расширения. Если закрый ключ или сертификат с таким же именем существует, возвращается ошибка. Если закрытый ключ и сертификат отсутствует, но запрос с таким именем существует, то такой запрос будет перезаписан.

    В случае успеха завершается с кодом 0.

### Подписание запроса (сервер)

    `crypt-pki cryptfile --signserver --internalname internalname [--userid userid]`

    Подписывает существующий запрос и создает сертификат сервера. Поле DNS в subject-alt-name задается равным значению `--internalname`. Пароль для ключа CA можно задать переменной EASYRSA_PASSIN или интерактивно.

    `--internalname` имя файла запроса для easy-rsa.

    `--userid` задает значение rfc822Name в subject-alt-name. Может быть использован для связи с другими системами управления пользователями. Если не задан, то устанавливается равным значению `--internalname`.

    В случае успеха завершается с кодом 0.

### Подписание запроса (клиент)

    `crypt-pki cryptfile --signclient --internalname internalname [--userid userid]`

        Подписывает существующий запрос и создает сертификат клиента. Поле DNS в subject-alt-name задается равным значению `--internalname`. Пароль для ключа CA можно задать переменной EASYRSA_PASSIN или интерактивно.

    `--internalname` имя файла запроса для easy-rsa.

    `--userid` задает значение rfc822Name в subject-alt-name. Может быть использован для связи с другими системами управления пользователями. Если не задан, то устанавливается равным значению `--internalname`.

    В случае успеха завершается с кодом 0.

### Информация о сертификате

    `crypt-pki cryptfile --info [ --internalname internalname | --serial serial ]`

    Выводит в stdout информацию о статусе сертификата. Сертификат может быть задан по имени файла `--internalname` или по серийному номеру `--serial`. Команда полезна для определения статуса сертификата, например когда известен только серийный номер.

    Серийный номер задается строкой нечувствительной к регистру, состоящей из hex октетов без префикса и разделителей. Например `--serial 0466a8ce8A193802df863E47F357157a`.

    Первая строка stdout может быть одной из:

- **ACTIVE** - сертификат присутствует в PKI и не отозван. Код возврата 0.

- **REVOKED** - сертификат присутствует в PKI и отозван. Код возврата 0.

- **NOTFOUND** - сертификат не найден в PKI. Код возврата 0.

Остальные строки stdout содержат прочую информацию о сертификате.

### Отзыв сертификата

    `crypt-pki cryptfile --revoke [ --internalname internalname | --serial serial ] --file crlfile`

    Отзывает сертификат, заданный по имени файла `--internalname` или по серийному номеру `--serial`. Пароль для ключа CA можно задать переменной EASYRSA_PASSIN или интерактивно.

    Серийный номер задается строкой нечувствительной к регистру, состоящей из hex октетов без префикса и разделителей. Например `--serial 0466a8ce8A193802df863E47F357157a`.

    `--file` путь к файлу вне контейнера, куда будет записан новый CRL. Независимо от того, установлено ли использование CRL или нет, файл CRL всегда присутствует в PKI. Независимо от результатов отзыва или вообще использования CRL, при отзыве требуется указать файл, куда будет выгружен обновленный CRL из контейнера.

    В случае успеха завершается с кодом 0.

### Новый CRL

    `crypt-pki cryptfile --crl --file crlfile`

    Пересоздает CRL и выгружает его из контейнера в файл `--file`. Пароль для ключа CA можно задать переменной EASYRSA_PASSIN или интерактивно.

    В случае успеха завершается с кодом 0.

### Шаблоны конфигурации OpenVpn

    `crypt-pki cryptfile --loadtemplate --file template`

    Загружает в контейнер шаблон для создания конфигурационных файлов OpenVpn.

    Конфигурационные файлы OpenVpn могут содержать ключи и сертификаты, серийные номера, параметры подключения к серверу итп, поэтому удобно генерировать такие конфигурационные файлы вместе с созданием клиентского сертификата. Образцы шаблонов устанавлены в каталоге `/usr/share/crypt-pki/templates`. Удобно создать отдельные шаблоны для клиентов разных платформ. Также разными шаблонами можно создавать файлы конфигурации, которые содержат в себе закрытые ключи клиента или используют хранилище сертификатов клиентской операционной системы.

    Шаблон имеет формат файла конфигурации OpenVpn. Переменные в тексте шаблона будут заменены на значения, взятые из сертификата, который будет использован при генерации конфига. Остальные данные будут перенесены без изменений.

    Переменные:

- **SUBSTKEYNAME** - имя файла клиентского сертификата (internalname).

- **SUBSTCA** - сертификат CA в формате PEM, ca.

- **SUBSTTLS** - ключ tls-crypt.

- **SUBSTCERT** - клиентский сертификат в формате PEM, cert.

- **SUBSTKEY** - клиентский закрытый ключ в формате PEM, key.

- **SUBSTCERTAPI** - директива cryptoapicert с отпечатком клиентского сертификата.

    Если закрытый ключ клиента присутствует в PKI, то при генерации конфига OpenVpn можно встроить ключ вместе с сертификатом прямо в конфиг (linux, windows, android, apple?). В этом случае в шаблоне следует использовать переменные **SUBSTKEY** и **SUBSTCERT**, вместо **SUBSTCERTAPI**. Такой файл конфигурации следует передавать клиенту по безопасному каналу связи чтобы не скомпроментировать закрытый ключ.

    Если закрытый ключ в PKI отсутствует, значит он есть у клиента, а в PKI есть только запрос и сертификат. Если клиент хранит свой закрытый ключ в системном хранилище (windows, apple?), то на ключ и сертификат можно ссылаться из конфига по отпечатку сертификата **SUBSTCERTAPI** и не использовать переменные **SUBSTKEY** и **SUBSTCERT**. В android указание **SUBSTCERTAPI** все равно требует выбора сертификата из системного хранилища при первом подключении.

В linux системные хранилища клиентских сертификатов не поддерживаются.

### Клиентский конфиг OpenVpn из шаблона

    `crypt-pki cryptfile --export-config --template tplname --internalname internalname --file configfile`

    Создает клиентский конфиг OpenVpn на основе загруженного ранее шаблона.

    `--template` имя шаблона, ранее загруженного в контейнер.

    `--internalname` файл клиентского сертификата для генерации конфига.

    `--file` файл вне контейнера в который будет выгружен готовый конфиг.

    В случае успеха завершается с кодом 0.

### Экспорт цепочки сертификатов PKCS #12

    `crypt-pki cryptfile --export-chain --internalname internalname --file chainfile`

    Экспортирует из PKI во внешний файл цепочку: CA сертификат, клиентский сертификат, закрытый ключ клиента. Закрытый ключ должен присутствовать в PKI. Контейнер PKCS #12 зашифрован с паролем, который можно задать интерактивно или переменной EASYRSA_PASSOUT.

    `--internalname` имя файла ключа и сертификата клиента, которые следует экспортировать.

    `--file` файл, куда будет выгружен контейнер PKCS #12.

    В случае успеха завершается с кодом 0.

### Экспорт ответа на запрос сертификата PKCS #7

    `crypt-pki cryptfile --export-response --internalname internalname --file chainfile`

    Экспортирует из PKI во внешний фал ответ на клиентский запрос сертификата. Закрытый ключ находится у клиента и ответ не содержит секретных данных.

    `--internalname` имя файла ключа и сертификата клиента, которые следует экспортировать.

    `--file` файл, куда будет выгружен контейнер PKCS #7.

    В случае успеха завершается с кодом 0.

### Экспорт цепочки сертификатов ZIP

    `crypt-pki cryptfile --export-zip --internalname internalname --file archive`

    Экспортирует из PKI во внешний файл архив, содержащий: CA сертификат, клиентский сертификат, закрытый ключ клиента, ключ tls-crypt для OpenVpn. Закрытый ключ должен присутствовать в PKI. Архив выгружается без защиты паролем и должен передаваться по защищенным каналам связи. Обычно используется для настройки серверов.

    `--internalname` имя файла ключа и сертификата клиента, которые следует экспортировать.

    `--file` файл, куда будет выгружен zip архив.

    В случае успеха завершается с кодом 0.

### Переменные окружения

- **CTKEY** содержит ключ к LUKS контейнеру. Если не задана, ключ запрашивается интерактивно.

- **EASYRSA_PASSIN** и **EASYRSA_PASSOUT** используются утилитой easy-rsa. Подробная информация о формате переменных в openssl-passphrase-options(1). Если не задана, запрашивается интерактивно.

- **SECD** устанавливается автоматически при выполнении `--exec` и указывает на точку монтирования.

### Примеры

    Создать новый контейнер `./cryptfile`, инициализировать PKI с использованием CRL. В случае успеха сохранить ключ в файле `./ctkey`:

```bash
ctkey=$(crypt-pki ./cryptfile --init --url "http://example.com/crl") && [ -n "$ctkey" ] && echo "$ctkey" > ./ctkey
```

    Создать CA с паролем ключа "Secret_CA_Password". Обычно создание CA происходит автоматически во время инициализации. Однако, если параметры инициализации нужно изменить, то после создания контейнера можно внести правки в конфиги `easy-rsa`, и пересоздать CA вручную:

```bash
echo "Secret_CA_Password" > "./capwd"
EASYRSA_PASSIN="pass:$(cat ./capwd)" EASYRSA_PASSOUT="$EASYRSA_PASSIN" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --exec --cmd "easy-rsa/easyrsa --req-cn=\"exampleCA\" build-ca"
```

    Пересоздать CRL, сохранить в `/var/www/crlfile.crl`. Пароли взять из файлов

```bash
EASYRSA_PASSIN="pass:$(cat ./capwd)" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --crl --file /var/www/crlfile.crl
```

    Создать новый запрос сертификата для сервера vpn.example.com с нешифрованным ключом

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --newreq --internalname vpn.example.com --nopass
```

    Создать новый запрос сертификата для клиента с ключом, зашифрованным паролем 1234. Клиент будет храниться в PKI под именем smith2, при этом CN будет user2. Если понадобится перевыпустить сертификат, новый будет иметь другое имя файла, но CN можно задать тот же

```bash
EASYRSA_PASSOUT="pass:1234" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --newreq --internalname smith2 --cn "user2" 
```

    Загрузить из файла `./client.req` клиентский запрос на выпуск сертификата и сохранить его в PKI под именем smith3

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --loadreq --file ./client.req --internalname smith3
```

    Подписать имеющиеся в PKI запросы

```bash
EASYRSA_PASSIN="pass:$(cat ./capwd)" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --signserver --internalname vpn.example.com
EASYRSA_PASSIN="pass:$(cat ./capwd)" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --signclient --internalname smith2 --userid alice_smith
EASYRSA_PASSIN="pass:$(cat ./capwd)" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --signclient --internalname smith3 --userid sandra_smith
```

    Получить информацию о сертификате

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --info --internalname smith3
```

    Отозвать сертификат и выгрузить обновленный CRL

```bash
EASYRSA_PASSIN="pass:$(cat ./capwd)" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --revoke --internalname smith2 --file /var/www/crlfile.crl
```

    Загрузить шаблон конфига OpenVpn и сгенерировать новый конфиг для клиента

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --loadtemplate --file /usr/share/crypt-pki/templates/win-api
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --export-config --template win-api --internalname smith3 --file ./config-win.ovpn
```

    Экспортировать из PKI сертификаты и ответ на клиентский запрос

```bash
EASYRSA_PASSOUT="pass:12345" CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --export-chain --internalname smith2 --file ./smith2.p12
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --export-response --internalname smith3 --file ./smith3.p7b
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --export-zip --internalname vpn.example.com --file ./server.zip
```

    Проверить свободное место в контейнере

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --exec --cmd "df -h \$SECD"
```

    Выполнить в контейнере набор инструкций с конвейером

```bash
CTKEY="$(cat ./ctkey)" crypt-pki ./cryptfile --exec --cmd "cat easy-rsa/vars|sed -n '/^[\t ]*#/d;/^[\t ]*$/d;p'"
```

## setup-montana

    Пакет выполняет настройку сервера montana.ajalo.com (сервер PKI).

    Подробное описание пакета см в инструкции администратора [README.ajalo.admin.md](README.ajalo.admin.md)

## setup-nevada

    Пакет выполняет настройку сервера nevada.ajalo.com (сервер VPN).

    Подробное описание пакета см в инструкции администратора [README.ajalo.admin.md](README.ajalo.admin.md)

## setup-ohio

    Пакет выполняет настройку сервера ohio.ajalo.com (сервер мониторинга).

    Подробное описание пакета см в инструкции администратора [README.ajalo.admin.md](README.ajalo.admin.md)
